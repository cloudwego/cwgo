// Code generated by cwgo (v0.0.1). DO NOT EDIT.

package user

import (
	"context"
	"github.com/cloudwego/cwgo/examples/mongo/getting-started/biz/doc/model/user"
	"github.com/cloudwego/cwgo/examples/mongo/getting-started/biz/doc/model/video"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func NewUserRepository(collection *mongo.Collection) UserRepository {
	return &UserRepositoryMongo{
		collection: collection,
	}
}

type UserRepositoryMongo struct {
	collection *mongo.Collection
}

func (r *UserRepositoryMongo) InsertOne(ctx context.Context, user *user.User) (interface{}, error) {
	result, err := r.collection.InsertOne(ctx, user)
	if err != nil {
		return nil, err
	}
	return result.InsertedID, nil
}

func (r *UserRepositoryMongo) InsertMany(ctx context.Context, user []*user.User) ([]interface{}, error) {
	var entities []interface{}
	for _, model := range user {
		entities = append(entities, model)
	}
	result, err := r.collection.InsertMany(ctx, entities)
	if err != nil {
		return nil, err
	}
	return result.InsertedIDs, nil
}

func (r *UserRepositoryMongo) FindUsernames(ctx context.Context, skip int64, limit int64) ([]*user.User, error) {
	if limit == 0 {
		limit = 5
	}
	cursor, err := r.collection.Find(ctx, bson.M{}, options.Find().SetSort(bson.M{
		"id": 1,
	}).SetProjection(bson.M{
		"username": 1,
	}).SetLimit(limit).SetSkip(skip))
	if err != nil {
		return nil, err
	}
	var entities []*user.User
	if err = cursor.All(ctx, &entities); err != nil {
		return nil, err
	}
	return entities, nil
}

func (r *UserRepositoryMongo) FindByUsernameAge(ctx context.Context, name1 string, name2 string, age int32) (*user.User, error) {
	var entity *user.User
	if err := r.collection.FindOne(ctx, bson.M{
		"And": []bson.M{
			{
				"Or": []bson.M{
					{
						"username": name1,
					}, {
						"username": name2,
					}},
			}, {
				"age": bson.M{
					"$gt": age,
				},
			}},
	}, options.FindOne().SetSort(bson.M{})).Decode(entity); err != nil {
		return nil, err
	}
	return entity, nil
}

func (r *UserRepositoryMongo) UpdateContact(ctx context.Context, contact *user.UserContact, id int64) (bool, error) {
	result, err := r.collection.UpdateOne(ctx, bson.M{
		"id": id,
	}, bson.M{
		"$set": bson.M{
			"contact": contact,
		},
	}, options.Update().SetUpsert(false))
	if err != nil {
		return false, err
	}
	return result.MatchedCount > 0, nil
}

func (r *UserRepositoryMongo) DeleteById(ctx context.Context, city string) (int, error) {
	result, err := r.collection.DeleteMany(ctx, bson.M{
		"city": city,
	})
	if err != nil {
		return 0, err
	}
	return int(result.DeletedCount), nil
}

func (r *UserRepositoryMongo) CountByAge(ctx context.Context, age1 int32, age2 int32) (int, error) {
	result, err := r.collection.CountDocuments(ctx, bson.M{
		"age": bson.M{
			"$gte": age1,
			"$lte": age2,
		},
	})
	if err != nil {
		return 0, err
	}
	return int(result), nil
}

func (r *UserRepositoryMongo) BulkOp(ctx context.Context, userInsert *user.User, userUpdate *user.User, id int64) (*mongo.BulkWriteResult, error) {
	var models []mongo.WriteModel
	models = append(models, mongo.NewInsertOneModel().SetDocument(userInsert))
	models = append(models, mongo.NewUpdateManyModel().SetFilter(bson.M{
		"id": id,
	}).SetUpdate(bson.M{
		"$set": userInsert,
	}).SetUpsert(false))
	return r.collection.BulkWrite(ctx, models)
}

func (r *UserRepositoryMongo) TransactionOp(ctx context.Context, client *mongo.Client, videoCollection *mongo.Collection, userInsert *user.User, userUpdate *user.User, id int64, videos []*video.Video) error {
	if err := client.UseSession(ctx, func(sessionContext mongo.SessionContext) error {
		if err := sessionContext.StartTransaction(); err != nil {
			return err
		}

		var models []mongo.WriteModel

		models = append(models, mongo.NewInsertOneModel().SetDocument(userInsert))
		models = append(models, mongo.NewUpdateManyModel().SetFilter(bson.M{
			"id": id,
		}).SetUpdate(bson.M{
			"$set": client,
		}).SetUpsert(false))

		if _, err := r.collection.BulkWrite(sessionContext, models); err != nil {
			if err = sessionContext.AbortTransaction(context.Background()); err != nil {
				return err
			}
			return err
		}

		var entities []interface{}

		for _, model := range videos {
			entities = append(entities, model)
		}

		if _, err := videoCollection.InsertMany(sessionContext, entities); err != nil {
			if err = sessionContext.AbortTransaction(context.Background()); err != nil {
				return err
			}
			return err
		}

		return sessionContext.CommitTransaction(context.Background())
	}); err != nil {
		return err
	}
	return nil
}
